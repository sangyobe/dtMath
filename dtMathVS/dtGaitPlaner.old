#pragma once

#if defined(_WIN32) || defined(__linux__)
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#elif defined(ARDUINO)
#include <Arduino.h>
#endif

#include "./dtMath/dtMath.h"
#include "dtSwingBezier.hpp"

#include <cmath>
#include <limits>

#define STANCE  0
#define SWING   1
#define TOTAL   2

template <uint8_t m_legNum, typename m_type = float>
class CdtGaitPlaner
{
public:
    uint8_t state[m_legNum];       // state 0 is stance and 1 is swing
    m_type ctrlParam[m_legNum];    // ctrlparam range [0 1]

private:
    m_type m_smpTime_ms;
    m_type m_elapsed_ms;

    m_type m_period_ms[3];          // [0]:stance time, [1]:swing time, [2]:stance + swing time
    m_type m_refPeriod_ms[3];       // [0]:stance time, [1]:swing time, [2]:stance + swing time
    m_type m_legPeriod_ms[m_legNum][3];    // [0]:stance time, [1]:swing time, [2]:stance + swing time
    m_type m_phaseDelay_pu[m_legNum];      // unit:[percent unit], 0 ~ 1

    m_type m_refState;
    m_type m_refCtrlParam;

    uint8_t m_stop;
    uint8_t m_updateStop[m_legNum];
    bool m_updatePeriod[m_legNum];
    uint8_t m_updateTarget[m_legNum];

    CdtVector3<m_type> m_startPos[m_legNum];
    CdtVector3<m_type> m_endPos[m_legNum];
    CdtVector3<m_type> m_startVel[m_legNum];
    CdtVector3<m_type> m_endVel[m_legNum];

    CdtVector3<m_type> m_swTargetPos;
    CdtVector3<m_type> m_stTargetVel;
    m_type m_height[m_legNum];

    CdtSwingBezier m_swingBezier[m_legNum];
    CdtSwingBezier m_stanceBezier[m_legNum];

public:
    CdtGaitPlaner();

    int8_t Init(const uint32_t sampleTime_us, const m_type stanceTime_ms, const m_type swingTime_ms,
        const m_type flPhase_pu, const m_type blPhase_pu, const m_type frPhase_pu, const m_type brPhase_pu);
    int8_t SetSampleTime(const uint32_t sampleTime_us);
    int8_t SetPeriod(const m_type stanceTime_ms, const m_type swingTime_ms);
    int8_t SetPhase(const m_type flPhase_pu, const m_type blPhase_pu, const m_type frPhase_pu, const m_type brPhase_pu);
    int8_t SetPhase(const uint8_t idx, const m_type phase_pu);
    int8_t SetStep(CdtVector3<m_type> &step, const m_type height);

    int8_t SetTarget(const uint8_t idx,
        CdtVector3<m_type> &startPos, CdtVector3<m_type> &endPos,
        CdtVector3<m_type> &startVel, CdtVector3<m_type> &endVel,
        const m_type height);
    int8_t SetTarget(CdtVector3<m_type> &endPos, const m_type height);

    void Start();
    void Stop();
    void Compute();

    CdtVector3<m_type>& Pos(uint8_t idx);
    CdtVector3<m_type>& Vel(uint8_t idx);

private:
    void ReferenceCPG();
    void FollowCPG(int idx);
};

template<uint8_t m_legNum, typename m_type>
inline CdtGaitPlaner<m_legNum, m_type>::CdtGaitPlaner()
{
    m_smpTime_ms = 1;
    m_elapsed_ms = 0;

    m_period_ms[STANCE] = 1000;
    m_period_ms[SWING] = 300;
    m_period_ms[TOTAL] = 1300;

    m_refPeriod_ms[STANCE] = m_period_ms[STANCE];
    m_refPeriod_ms[SWING] = m_period_ms[SWING];
    m_refPeriod_ms[TOTAL] = m_period_ms[TOTAL];

    m_refState = STANCE;
    m_refCtrlParam = 2;

    for (int i = 0; i < m_legNum; i++)
    {
        state[i] = STANCE;
        ctrlParam[i] = 2;
        m_legPeriod_ms[i][STANCE] = m_period_ms[0];
        m_legPeriod_ms[i][SWING] = m_period_ms[1];
        m_legPeriod_ms[i][TOTAL] = m_period_ms[2];

        m_updatePeriod[i] = false;
        m_updateTarget[i] = false;
    }

    // Walking Phase
    m_phaseDelay_pu[0] = 0.25;  // Front Left
    m_phaseDelay_pu[1] = 0;     // Back Left (ref)
    m_phaseDelay_pu[2] = 0.75;  // Front Left
    m_phaseDelay_pu[3] = 0.5;   // Back Left
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::Init(const uint32_t sampleTime_us, const m_type stanceTime_ms, const m_type swingTime_ms,
    const m_type flPhase_pu, const m_type blPhase_pu, const m_type frPhase_pu, const m_type brPhase_pu)
{
    if (sampleTime_us <= 0)
    {
        m_smpTime_ms = 1;
        return -1;
    }

    m_smpTime_ms = sampleTime_us / 1000.0f;

    m_elapsed_ms = 0;

    m_period_ms[STANCE] = stanceTime_ms;
    m_period_ms[SWING] = swingTime_ms;
    m_period_ms[TOTAL] = stanceTime_ms + swingTime_ms;

    m_refPeriod_ms[STANCE] = m_period_ms[STANCE];
    m_refPeriod_ms[SWING] = m_period_ms[SWING];
    m_refPeriod_ms[TOTAL] = m_period_ms[TOTAL];

    m_refState = STANCE;
    m_refCtrlParam = 2;

    for (int i = 0; i < m_legNum; i++)
    {
        state[i] = STANCE;
        ctrlParam[i] = 2;
        m_legPeriod_ms[i][STANCE] = m_period_ms[STANCE];
        m_legPeriod_ms[i][SWING] = m_period_ms[SWING];
        m_legPeriod_ms[i][TOTAL] = m_period_ms[TOTAL];

        m_updatePeriod[i] = false;
        m_updateTarget[i] = false;
    }

    m_phaseDelay_pu[0] = flPhase_pu;
    m_phaseDelay_pu[1] = blPhase_pu;
    m_phaseDelay_pu[2] = frPhase_pu;
    m_phaseDelay_pu[3] = brPhase_pu;

    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetSampleTime(const uint32_t sampleTime_us)
{
    if (sampleTime_us <= 0)
    {
        m_smpTime_ms = 1;
        return -1;
    }

    m_smpTime_ms = sampleTime_us / 1000.0f;

    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetPeriod(const m_type stanceTime_ms, const m_type swingTime_ms)
{
    m_period_ms[STANCE] = stanceTime_ms;
    m_period_ms[SWING] = swingTime_ms;
    m_period_ms[TOTAL] = stanceTime_ms + swingTime_ms;

    m_updatePeriod[0] = true;
    m_updatePeriod[1] = true;
    m_updatePeriod[2] = true;
    m_updatePeriod[3] = true;
    
    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetPhase(const m_type flPhase_pu, const m_type blPhase_pu, const m_type frPhase_pu, const m_type brPhase_pu)
{
    m_phaseDelay_pu[0] = flPhase_pu;
    m_phaseDelay_pu[1] = blPhase_pu;
    m_phaseDelay_pu[2] = frPhase_pu;
    m_phaseDelay_pu[3] = brPhase_pu;

    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetPhase(const uint8_t idx, const m_type phase_pu)
{
    if (idx > 3) return -1;

    m_phaseDelay_pu[idx] = phase_pu;

    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetTarget(const uint8_t idx, CdtVector3<m_type>& startPos, CdtVector3<m_type>& endPos, CdtVector3<m_type>& startVel, CdtVector3<m_type>& endVel, const m_type height)
{
    m_updateTarget[idx] = true;
    m_startPos[idx] = startPos;
    m_endPos[idx] = endPos;
    m_startVel[idx] = startVel;
    m_endVel[idx] = endVel;
    m_height[idx] = height;

    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline int8_t CdtGaitPlaner<m_legNum, m_type>::SetTarget(CdtVector3<m_type>& endPos, const m_type height)
{
    for (uint8_t i = 0; i < m_legNum; i++)
    {
        m_updateTarget[i] = true;
        m_startPos[i].SetZero();
        m_startVel[i].SetZero();
        m_endPos[i] = endPos;
        m_endVel[i].SetZero();
        m_height[i] = height;
    }
    return 0;
}

template<uint8_t m_legNum, typename m_type>
inline void CdtGaitPlaner<m_legNum, m_type>::Start()
{
    m_stop = 0;
    m_elapsed_ms = 0;

    for (uint8_t i = 0; i < m_legNum; i++)
        m_updateStop[i] = 0;
}

template<uint8_t m_legNum, typename m_type>
inline void CdtGaitPlaner<m_legNum, m_type>::Stop()
{
    for (uint8_t i=0; i<m_legNum; i++)
        m_updateStop[i] = 1;
}

template<uint8_t m_legNum, typename m_type>
inline void CdtGaitPlaner<m_legNum, m_type>::Compute()
{
    ReferenceCPG();

    for (uint8_t i = 0; i < m_legNum; i++)
    {
        FollowCPG(i);   // Front Left
        if (state[i] == SWING) m_swingBezier[i].Compute(ctrlParam[i]);
    }

    m_elapsed_ms += m_smpTime_ms;

    if (m_elapsed_ms > m_refPeriod_ms[TOTAL])
    {
        m_elapsed_ms = 0;
    }
}

template<uint8_t m_legNum, typename m_type>
inline CdtVector3<m_type>& CdtGaitPlaner<m_legNum, m_type>::Pos(uint8_t idx)
{
    if (state[idx] == SWING) return m_swingBezier[idx].pos_x;
    else return m_stanceBezier[idx].pos_x;
}

template<uint8_t m_legNum, typename m_type>
inline CdtVector3<m_type>& CdtGaitPlaner<m_legNum, m_type>::Vel(uint8_t idx)
{
    if (state[idx] == SWING) return m_swingBezier[idx].vel_xps;
    else return m_stanceBezier[idx].vel_xps;
}

template<uint8_t m_legNum, typename m_type>
inline void CdtGaitPlaner<m_legNum, m_type>::ReferenceCPG()
{
    m_type mod = m_elapsed_ms % (m_refPeriod_ms[TOTAL]);

    if (mod > m_refPeriod_ms[SWING])
    {
        m_refState = STANCE;
        m_refCtrlParam = (mod - m_refPeriod_ms[SWING]) / m_refPeriod_ms[STANCE];

        // update period
        m_refPeriod_ms[STANCE] = m_period_ms[STANCE];  // stance
        m_refPeriod_ms[SWING] = m_period_ms[SWING];   // swing
        m_refPeriod_ms[TOTAL] = m_period_ms[TOTAL];   // stance + swing
    }
    else
    {
        m_refState = SWING;
        m_refCtrlParam = mod / m_refPeriod_ms[SWING];
    }
}

template<uint8_t m_legNum, typename m_type>
inline void CdtGaitPlaner<m_legNum, m_type>::FollowCPG(int idx)
{
    // making the dependency of follow cpg on ref cpg
    m_type period_pu, swingRatio_pu;

    if (m_stop >= m_legNum) return;

    if (refState == STANCE)
        period_pu = (m_refCtrlParam * m_legPeriod_ms[idx][STANCE] + m_legPeriod_ms[idx][SWING]) / m_legPeriod_ms[idx][TOTAL];
    else
        period_pu = (m_refCtrlParam * m_legPeriod_ms[idx][SWING]) / m_legPeriod_ms[idx][TOTAL];

    period_pu -= m_phaseDelay_pu[idx];
    if (period_pu < 0) period_pu += 1;

    swingRatio_pu = m_legPeriod_ms[idx][SWING] / m_legPeriod_ms[idx][TOTAL]; // ratio of swing time

    if (period_pu <= swingRatio_pu)
    {
        state[idx] = SWING;
        ctrlParam[idx] = period_pu / swingRatio_pu;

        // update swing target
        if (m_updateTarget[idx] == SWING)
        {
            m_swingBezier[idx].SetTarget(
                m_stanceBezier[idx].pos_x, m_stanceBezier[idx].vel_xps,
                m_swTargetPos, m_swTargetVel, m_height[idx]);
            m_updateTarget[idx] = STANCE;
        }
    }
    else
    {
        state[idx] = STANCE;
        ctrlParam[idx] = (period_pu - swingRatio_pu) / (1 - swingRatio_pu);

        // update stance target
        if (m_updateTarget[idx] == STANCE)
        {
            m_stanceBezier[idx].SetTarget(
                m_swingBezier[idx].pos_x, m_swingBezier[idx].vel_xps,
                m_stTargetPos, m_stTargetVel, 0);
            m_updateTarget[idx] = SWING;
        }

        // update period
        if (m_updatePeriod[idx])
        {
            m_legPeriod_ms[idx][STANCE] = m_period_ms[STANCE];  // stance
            m_legPeriod_ms[idx][SWING] = m_period_ms[SWING];    // swing
            m_legPeriod_ms[idx][TOTAL] = m_period_ms[TOTAL];    // stance + swing
            m_swingBezier[idx].SetPeriod(m_legPeriod_ms[SWING]);
            m_stanceBezier[idx].SetPeriod(m_legPeriod_ms[STANCE]);
            m_updatePeriod[idx] = false;
        }

        // update stop
        switch (m_updateStop[idx])
        {
        case 1:
            m_updateStop[idx]++;
            m_startPos[idx].SetZero();
            m_endPos[idx].SetZero();
            m_startVel[idx].SetZero();
            m_endVel[idx].SetZero();
            m_swingBezier[idx].SetTarget(m_startPos[idx], m_endPos[idx], m_startVel[idx], m_endVel[idx], m_height[idx]);
            break;
        case 2:
            m_stop++;
            break;
        }
    }
}
